\ProvidesPackage{scheduling}
\RequirePackage{tikz}
\RequirePackage{xargs}

\newcounter{task}
\newcounter{resa}
\newcounter{hole}

\newcommand{\tlabel}{nolabel}

% <<< Nombre fixé de machines (initialisation des abscisses à 0)
\newenvironmentx{ordo}[7][1=12, 5=a, 6=0, 7=0]
% 1 : Longueur Max en cm
% 2 : Nbre de machines
% 3 : Pas en abscisse
% 4 : xmax
% 5 : Largeur Max
% 6 : Début de la numérotation des machines
% 7 : Début de la numérotation en abscisse
{

    \setcounter{task}{0}
    \setcounter{resa}{0}
    \setcounter{hole}{0}
    \begin{center}
    \begin{tikzpicture}[>=latex]
 
        % Si la taille de l'ordo est fixée alors on calcule l'épaisseur d'une ligne, sinon on la
        % fixe à 1
        \ifthenelse{\equal{#5}{a}}
        {\pgfmathparse{1} \let\height\pgfmathresult}
        {\pgfmathparse{#5/#2} \let\height\pgfmathresult}
 
        % Calcul de la longueur d'un pas en abscisse
        \pgfmathparse{#3/#4 * (#1-1)} \let\xpas\pgfmathresult
        % Calcul du nombre de pas nécessaires pour dépasser la borne
        \pgfmathparse{int(#4/#3)} \let\nbpas\pgfmathresult
        % Longueur d'un pas unitaire
        \pgfmathparse{\xpas/#3} \let\unitxpas\pgfmathresult

        % Calcul de l'abcisse maximale
        \pgfmathparse{#1-1+\xpas} \let\begx\pgfmathresult
        % Calcul de l'ordonnée maximale
        \pgfmathparse{#2*\height} \let\endy\pgfmathresult
        
        \draw[thick] (\begx,0) -- (0,0) -- (0,\endy) -- (\begx,\endy);
        \draw[thick,dashed] (\begx,0) -- (\begx+\xpas,0);
        \draw[thick,dashed] (\begx,\endy) -- (\begx+\xpas,\endy);

        \node[below] at (0, 0) {$#7$};

        \foreach \x in {1,...,\nbpas}{
            \pgfmathparse{\x * \xpas} \let\abscisse\pgfmathresult
            \pgfmathparse{int(\x * #3)} \let\xlabel\pgfmathresult

            % TODO Faire le test est un nombre
            \IfDecimal{#7}
            {
                \pgfmathparse{int(\xlabel + #7)} \let\supxlab\pgfmathresult
                \node[below] at (\abscisse, 0) {$\supxlab$};
            }
            {\node[below] at (\abscisse, 0) {$#7 + \xlabel$};}

            \draw[dotted] (\abscisse,0) to (\abscisse,\endy);
        }

        \pgfmathparse{(\nbpas + 1) * \xpas} \let\abscisse\pgfmathresult
        \node[above] at (\abscisse, -0.4) {$\dots$};

        \foreach \y in {1,...,#2}{
            \pgfmathparse{\y * \height} \let\ordmachine\pgfmathresult
            \pgfmathparse{\ordmachine - (0.5*\height)} \let\ordlabel\pgfmathresult

            \ifthenelse{\equal{\y}{1}}
            {\node[left] at (0, \ordlabel) {$M_{#6}$};}
            {
                \pgfmathparse{int(\y - 1)} \let\ylabel\pgfmathresult
                % TODO Tester s'il s'agit d'un entier
                \IfDecimal{#6}
                {
                    \pgfmathparse{int(#6 + \ylabel)} \let\ysuplabel\pgfmathresult
                    \node[left] at (0, \ordlabel) {$M_{\ysuplabel}$};
                }
                {\node[left] at (0, \ordlabel) {$M_{#6 + \ylabel}$};}
            }
            \draw[dotted] (0, \ordmachine) to (\begx + \xpas, \ordmachine);
        }
}
{\end{tikzpicture}\end{center}}
% >>>
% <<< k machines k non fixé
\newenvironmentx{ordok}[5][1=12, 5=a]
% 1 : Max
% 2 : Nbre de machines avant ...
% 3 : Pas en abscisse
% 4 : xmax
% 5 : Largeur max
{
    \setcounter{task}{0}
    \setcounter{resa}{0}
    \setcounter{hole}{0}
    \begin{center}
    \begin{tikzpicture}[>=latex]
        \ifthenelse{\equal{#5}{a}}
        {\pgfmathparse{1} \let\height\pgfmathresult}
        {\pgfmathparse{#5/#2} \let\height\pgfmathresult}
 
        \pgfmathparse{#3/#4 * #1} \let\xpas\pgfmathresult
        \pgfmathparse{int(#4/#3)} \let\nbpas\pgfmathresult
        \pgfmathparse{\xpas/#3} \let\unitxpas\pgfmathresult
        
        \pgfmathparse{#1-1+\xpas} \let\begx\pgfmathresult
        \pgfmathparse{#2*\height} \let\machheight\pgfmathresult
        \pgfmathparse{\machheight + 2*\height} \let\endy\pgfmathresult

        \draw[thick] (\begx+\xpas,0) -- (0,0) -- (0,\endy) -- (\begx+\xpas,\endy);
        \draw[thick,dashed] (\begx,0) -- (\begx+\xpas,0);
        \draw[thick,dashed] (\begx,\endy) -- (\begx+\xpas,\endy);

        \node[below] at (0, 0) {$0$};

        \foreach \x in {1,...,\nbpas}{
            \pgfmathparse{\x * \xpas} \let\abscisse\pgfmathresult
            \pgfmathparse{int(\x * #3)} \let\xlabel\pgfmathresult

            \node[below] at (\abscisse, 0) {$\xlabel$};
            \draw[dotted] (\abscisse,0) to (\abscisse,\machheight);
            \draw[dotted] (\abscisse,\machheight+1) to (\abscisse,\endy);
        }

        \pgfmathparse{(\nbpas + 1) * \xpas} \let\abscisse\pgfmathresult
        \node[above] at (\abscisse, -0.4) {$\dots$};

        \foreach \y in {1,...,#2}{
            \pgfmathparse{\y * \height} \let\ordmachine\pgfmathresult
            \pgfmathparse{\ordmachine - (0.5*\height)} \let\ordlabel\pgfmathresult

            \node[left] at (0, \ordlabel) {$M_\y$};
            \draw[dotted] (0, \ordmachine) to (\begx + \xpas, \ordmachine);
        }

        \pgfmathparse{\height*0.6}\let\temporaryvariable\pgfmathresult
        \node[left] at (0, \machheight + \temporaryvariable) {$\vdots$};
        \pgfmathparse{\endy - 0.5*\height}\let\temporaryvariable\pgfmathresult
        \node[left] at (0, \temporaryvariable) {$k$};
        \pgfmathparse{\endy - \height}\let\temporaryvariable\pgfmathresult
        \draw[dotted]  (0, \temporaryvariable) to (\begx+\xpas, #2 + 1);
}
{\end{tikzpicture}\end{center}}
% >>>
% <<< \newtask[label]{duree}{machine}{début}
% TODO Vérifier que le nombre de machines est suffisant
\newcommand{\newtask}[4][n]{
    % 1 : Label de la tâche
    % 2 : Durée de la tâche
    % 3 : Numéro de machine
    % 4 : Date de début
    
    \ifthenelse{\equal{#1}{n}}
    {\addtocounter{task}{1}
    \renewcommand{\tlabel}{$T_{\thetask}$}}
    {\renewcommand{\tlabel}{#1}}

    \pgfmathparse{#4*\unitxpas} \let\initx\pgfmathresult
    \pgfmathparse{(#3*\height)-(0.9*\height)}       \let\inity\pgfmathresult
    \pgfmathparse{#2*\unitxpas} \let\longx\pgfmathresult
    \pgfmathparse{\height*0.8}  \let\largy\pgfmathresult

    \fill[black!30] (\initx, \inity) rectangle +(\longx, \largy);
    \node at (\initx + \longx/2, \inity + \largy/2) {\tlabel};
}
% >>>
% <<< \newhyptask[label]{duree}{machine}{début}
% TODO Vérifier que le nombre de machines est suffisant
\newcommand{\newhyptask}[3]{
    % 1 : Durée de la tâche
    % 2 : Numéro de machine
    % 3 : Date de début
    
    \pgfmathparse{#3*\unitxpas} \let\initx\pgfmathresult
    \pgfmathparse{(#2-0.9)*\height)}       \let\inity\pgfmathresult
    \pgfmathparse{#1*\unitxpas} \let\longx\pgfmathresult
    \pgfmathparse{\height*0.8}  \let\largy\pgfmathresult

    \draw[dashed] (\initx, \inity) rectangle +(\longx, \largy);
}
% >>>
%% <<< \newunlabeledresa{duree}{machine}{debut}
%\newcommand{\newresa}[3]{
%    % 1 : Durée de la réservation
%    % 2 : Numéro de machine
%    % 3 : Date de début
%    \pgfmathparse{#3*\unitxpas} \let\initx\pgfmathresult
%    \pgfmathparse{#2-0.9}       \let\inity\pgfmathresult
%    \pgfmathparse{#1*\unitxpas} \let\longx\pgfmathresult
    %\pgfmathparse{\height*0.8}  \let\largy\pgfmathresult
%
%    \fill[black] (\initx, \inity) rectangle +(\longx, \largy);
%}
%% >>>
% <<< \newresa[label]{duree}{machine}{debut}
\newcommand{\newresa}[4][n]{
    % 1 : Label de la réservation
    % 2 : Durée de la réservation
    % 3 : Numéro de machine
    % 4 : Date de début
    
    \ifthenelse{\equal{#1}{n}}
    {\addtocounter{resa}{1}
    \renewcommand{\tlabel}{$R_{\theresa}$}}
    {\renewcommand{\tlabel}{#1}}

    \pgfmathparse{#4*\unitxpas} \let\initx\pgfmathresult
    \pgfmathparse{(#3*\height)-(0.9*\height)}       \let\inity\pgfmathresult
    \pgfmathparse{#2*\unitxpas} \let\longx\pgfmathresult
    \pgfmathparse{\height*0.8}  \let\largy\pgfmathresult

    \fill[black] (\initx, \inity) rectangle +(\longx, \largy);
    \node[white] at (\initx + \longx/2, \inity + \largy/2) {\tlabel};
}
% >>>
% <<< \newhole[label]{duree}{machine}{debut}
\newcommand{\newhole}[4][n]{
    % 1 : Durée du trou
    % 2 : Numéro de machine
    % 3 : Date de début
    % 4 : Label du trou
    
    \ifthenelse{\equal{#1}{n}}
    {\addtocounter{hole}{1}
    \renewcommand{\tlabel}{$h_{\thehole}$}}
    {\renewcommand{\tlabel}{#1}}

    \pgfmathparse{#4*\unitxpas} \let\initx\pgfmathresult
    \pgfmathparse{(#3*\height)-(0.8*\height)}       \let\inity\pgfmathresult
    \pgfmathparse{#2*\unitxpas} \let\longx\pgfmathresult

    \node at (\initx + \longx/2, \inity + 0.35*\height) {\tlabel};
    \draw[<->] (\initx, \inity) to (\initx + \longx, \inity);
}
% >>>
% <<< \newbeghole[label]{duree}{machine}
\newcommand{\newbeghole}[3][n]{
    % 1 : Label du trou
    % 2 : Durée du trou
    % 3 : Numéro de machine
    
    \ifthenelse{\equal{#1}{n}}
    {\addtocounter{hole}{1}
    \renewcommand{\tlabel}{$h_{\thehole}$}}
    {\renewcommand{\tlabel}{#1}}

    \pgfmathparse{0*\unitxpas} \let\initx\pgfmathresult
    \pgfmathparse{(#3*\height)-(0.8*\height)}       \let\inity\pgfmathresult
    \pgfmathparse{#2*\unitxpas} \let\longx\pgfmathresult

    \node at (\initx + \longx/2, \inity + 0.35*\height) {\tlabel};
    \draw[->] (\initx, \inity) to (\initx + \longx, \inity);
    \draw[-,dashed] (\initx - 1, \inity) to (\initx, \inity);
}
% >>>
% <<< \newendhole[label]{duree}{machine}{debut}
\newcommand{\newendhole}[4][n]{
    % 1 : Label du trou
    % 2 : Durée du trou
    % 3 : Numéro de machine
    % 4 : Date de début
    
    \ifthenelse{\equal{#1}{n}}
    {\addtocounter{hole}{1}
    \renewcommand{\tlabel}{$h_{\thehole}$}}
    {\renewcommand{\tlabel}{#1}}

    \pgfmathparse{#4*\unitxpas} \let\initx\pgfmathresult
    \pgfmathparse{(#3*\height)-(0.8*\height)}       \let\inity\pgfmathresult
    \pgfmathparse{#2*\unitxpas} \let\longx\pgfmathresult

    
    \node at (\initx + \longx/2, \inity + 0.35*\height) {\tlabel};
    \draw[<-] (\initx, \inity) to (\initx + \longx, \inity);
    \draw[-,dashed] (\initx + \longx, \inity) to (\initx + \longx + 2*\unitxpas, \inity);
}
% >>>
% <<< \adjust{nbmachine}{debmachine}
\newcommand{\adjust}[2]{
    \pgfmathparse{(#1-0.2)*\height}       \let\longy\pgfmathresult
    \pgfmathparse{(#2-0.9)*\height}       \let\inity\pgfmathresult

    \fill[black!0] (0, \inity) rectangle +(1, \longy);
}
% >>>


% <<< Taches
%% Début d'une tâche
\newcommand{\st}[1]{ r^{\mathcal{T}}_{#1} }
%% Fin d'une tâche
\newcommand{\ct}[1]{ \widetilde{d}^{\mathcal{T}}_{#1} }
%% Durée d'une tâche
\newcommand{\pt}[1]{ p^{\mathcal{T}}_{#1} }
% >>>
% <<< Resa
%% Début d'une réservation
\newcommand{\sres}[1]{ r^{\mathcal{R}}_{#1} }
%% Fin d'une réservation
\newcommand{\cres}[1]{ \widetilde{d}^{\mathcal{R}}_{#1} }
%% Durée d'une réservation
\newcommand{\pres}[1]{ p^{\mathcal{R}}_{#1} }
% >>>
% <<< Hole
%% Début d'un trou
\newcommand{\sho}[1]{ r^{\mathcal{H}}_{#1} }
%% Fin d'un trou
\newcommand{\cho}[1]{ \widetilde{d}^{\mathcal{H}}_{#1} }
%% Durée d'un trou
\newcommand{\pho}[1]{ p^{\mathcal{H}}_{#1} }
% >>>
% <<< Evénement général
%% Début d'un événement général (tache ou réservation)
\newcommand{\sgen}[1]{ r_{#1} }
%% Fin d'un événement général
\newcommand{\cgen}[1]{ \widetilde{d}_{#1} }
%% Durée d'un événement général
\newcommand{\pgen}[1]{ p_{#1} }
% >>>
% <<< Intervalle
%% Début d'un intervalle
\newcommand{\sint}[1]{ s_{#1} }
%% Fin d'un intervalle général
\newcommand{\cint}[1]{ c_{#1} }
%% Durée d'un intervalle
\newcommand{\pint}[1]{ l_{#1} }
% >>>

% <<< Notations
\newcommand{\authmach}[1]{$#1$-\emph{disponible}}
\newcommand{\tphase}[0]{phase}
\newcommand{\nbphase}[0]{I_{max}^{\mathcal{T}}}
\newcommand{\nbevphase}[0]{I_{max}^{\mathcal{E}}}
\newcommand{\iephase}[1]{\mathcal{T}^{#1}}
% >>>
